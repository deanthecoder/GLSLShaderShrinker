using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Windows.Input;
using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;
using Shrinker.Avalonia.Commands;
using Shrinker.Avalonia.Models;

namespace Shrinker.Avalonia.ViewModels;

using System.Windows.Input;

public class MainWindowViewModel : ViewModelBase
{
    public List<CombinedDiff> Diffs { get; } = new();
    public ICommand LaunchProjectPage { get; } = new RelayCommand(() => Process.Start(new ProcessStartInfo("https://github.com/deanthecoder/GLSLShaderShrinker") { UseShellExecute = true }));
    
    public MainWindowViewModel()
    {
        var oldText = "// ED-209 (https://www.shadertoy.com/view/wsGczG)\n//\n// I've always loved the (original) Robocop movie, but have never\n// felt confident enough to try modelling ED-209.\n// I hope you like it!\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n#define MIN_DIST      0.0015\n#define MAX_DIST      64.0\n#define MAX_STEPS     120.0\n#define SHADOW_STEPS  30.0\n\nfloat stretch, gunsUp, gunsForward, edWalk, edTwist, edDown, edShoot, doorOpen, glow;\n\n//#define AA  // Enable this line if your GPU can take it!\n\nstruct MarchData {\n    float d;\n    vec3 mat;        // RGB\n    float specPower; // 0: None, 30.0: Shiny\n};\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n    return mix(out1, out2, clamp((f - in1) / (in2 - in1), 0.0, 1.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdChamferedCube(vec3 p, vec3 r, float c) {\n    float cube = sdBox(p, r);\n    p.xz *= rot(3.141 / 4.0);\n    r.xz *= -c / 1.41 + 1.41;\n    return max(cube, sdBox(p, r));\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n  float rba  = rb-ra,\n     baba = dot(b-a,b-a),\n     papa = dot(p-a,p-a),\n     paba = dot(p-a,b-a)/baba,\n     x = sqrt( papa - paba*paba*baba ),\n     cax = max(0.0,x-((paba<0.5)?ra:rb)),\n     cay = abs(paba-0.5)-0.5,\n     k = rba*rba + baba,\n     f = clamp( (rba * (x - ra) + paba * baba) / k, 0.0, 1.0 ),\n     cbx = x - ra - f * rba,\n     cby = paba - f,\n     s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba, cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdOctogon(vec2 p, float r)\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623);\n    p = abs(p);\n    p -= 2.0 * min(dot(vec2( k.x, k.y), p), 0.0) * vec2( k.x, k.y);\n    p -= 2.0 * min(dot(vec2(-k.x, k.y), p), 0.0) * vec2(-k.x, k.y);\n    p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n    return length(p) * sign(p.y);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro),\n         right = normalize(cross(vec3(0.0, 1.0, 0.0), forward)),\n         up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nMarchData minResult(MarchData a, MarchData b) {\n    if (a.d < b.d) return a;\n    return b;\n}\n\nvoid setBodyMaterial(inout MarchData mat) {\n    mat.mat = vec3(0.36, 0.45, 0.5);\n    mat.specPower = 30.0;\n}\n\nfloat legWalkAngle(float f) { return sin(edWalk * 3.141 * 6.0 * f) * 0.2; }\nfloat edZ() { return mix(5.0, -2.0, edWalk); }\nfloat fireShock() { return abs(sin(edShoot * 3.1415 * 25.0)); }\n\nfloat headSphere(vec3 p) {\n    return (length(p / vec3(1.0, 0.8, 1.0)) - 1.0) * 0.8;\n}\n\nMarchData headVisor(vec3 p, float h, float bump) {\n    bump *= sin(p.x * 150.0) * sin(p.y * 150.0) * 0.002;\n\n    MarchData result;\n\n    result.d = sdBox(p, vec3(1.0, h, 2.0));\n    result.d = max(mix(result.d, headSphere(p), 0.57), -p.y) - bump;\n    \n    result.mat = vec3(0.05);\n    result.specPower = 30.0;\n    return result;\n}\n\nMarchData headLower(vec3 p) {\n    vec3 op = p;\n\n    // Start by mirroring the visor.\n    MarchData r = headVisor(p * vec3(0.95, -1.4, 0.95), 1.0, 0.0);\n    \n    // Add the side panels.\n    float roof = max(max(headVisor((p + vec3(0.0, 0.01, 0.0)) * vec3(0.95), 1.0, 0.0).d, p.y - 0.35), p.y * 0.625 - p.z - 0.66);\n    r.d = min(r.d, roof);\n\n    // 'Wings'.\n    p.xy *= rot(0.075 * (gunsUp - 1.0) * sign(p.x));\n    p.x = abs(p.x) - 1.33;\n    p.y -= 0.1 - p.x * 0.1;\n    r.d = min(r.d, sdBox(p, vec3(0.4, 0.06 * (1.0 - p.x), 0.3 - (p.x * 0.2))));\n    p = op;\n    \n    // Cut out a mouth grill.\n    p.y = abs(abs(p.y + 0.147) - 0.1 * 0.556) - 0.05 * 0.556;\n    r.d = max(r.d, -sdBox(p + vec3(0.0, 0.0, 1.5), vec3(mix(0.25, 0.55, -op.y), 0.015, 0.1)));\n    \n    // 'Cheeks'.\n    p = op;\n    p.y = abs(p.y + 0.16) - 0.06;\n    p.z -= -1.1;\n    float cheeks = max(sdCappedCylinder(p.xzy, 1.0, 0.03), -sdCappedCylinder(p.xzy, 0.55, 1.0));\n    cheeks = max(cheeks, p.z + 0.2);\n    r.d = max(r.d, -cheeks);\n    \n    setBodyMaterial(r);\n    return r;\n}\n\nMarchData gunPod(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    \n    p.yz += vec2(0.1, 0.45);\n\n    // Carousel.\n    const float rr = 0.35, chamfer = 0.1;\n    vec3 pp = p;\n    pp.z = abs(pp.z) - 0.5;\n    r.d = sdCappedCone(pp, vec3(0.0), vec3(0.0, 0.0, -chamfer), rr - chamfer, rr);\n    r.d = min(r.d, sdCappedCylinder(p, rr, 0.4));\n    \n    // Triangle nobble.\n    pp = vec3(p.x, 0.28 - p.y, p.z);\n    r.d = min(r.d, sdTriPrism(pp, vec2(0.1, 0.5)));\n\n    // Square outriggers.\n    pp = p;\n    pp.x = abs(p.x);\n    pp.xy *= rot(3.141 / 4.0);\n    float bump = sign(sin(pp.z * 33.3)) * 0.003,\n          d = sdBox(pp, vec3(0.1 - bump, 0.38 - bump, 0.34)) - 0.02;\n    \n    // Barrels.\n    pp = p - vec3(0.0, 0.0, -0.6);\n    pp.x = abs(pp.x) - 0.1;\n    d = min(d, sdCappedCylinder(pp, 0.06, 0.15));\n    d = min(d, sdCappedCylinder(pp + vec3(0.0, 0.12, -0.05), 0.06, 0.05));\n    d = min(d, sdBox(p + vec3(0.0, 0.0, 0.54), vec3(0.1, 0.06, 0.04)));\n    if (d < r.d) {\n        d = max(d, -sdCappedCylinder(pp + vec3(0.0, 0.0, 0.1), 0.03, 0.2));\n        r.d = d;\n        r.mat = vec3(0.02);\n    }\n    \n    // Muzzle flash.\n    float fs = fireShock();\n    if (fs > 0.5) {\n        d = sdCappedCylinder(pp, 0.01 + pp.z * 0.05, fract(fs * 3322.423) * 0.5 + 0.9);\n        if (d < r.d) {\n            r.d = d;\n            r.mat = vec3(1.0);\n            glow += 0.1 / (0.01 + d * d * 400.0);\n        }\n    }\n   \n    return r;\n}\n\nMarchData arms(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n\n    // Position origin.\n    p.x = abs(p.x);\n    p.yz += vec2(0.24, -0.0);\n    p.xy *= rot(0.15 * (gunsUp - 1.0));\n    \n    // Shoulder and forearm.\n    const vec3 elbow = vec3(1.5, 0.0, 0.0), wrist = elbow - vec3(0.0, 0.0, 0.3);\n    r.d = min(sdCapsule(p, vec3(0.0), elbow, 0.2), sdCapsule(p, elbow, wrist, 0.2));\n    \n    // Gunz.\n    p -= wrist;\n    p.z -= gunsForward * 0.15;\n    return minResult(r, gunPod(p));\n}\n\nfloat toe(vec3 p) {\n    p.yz += vec2(0.1, 0.32);\n    return max(sdBox(p, vec3(0.3 + 0.2 * (p.z - 0.18) - (p.y * 0.456) * 0.5, 0.3 + 0.2 * cos((p.z - 0.18) * 3.69), 0.35)), 0.1 - p.y);\n}\n\nfloat foot(vec3 p) {\n    p.z += 0.8;\n    p.yz *= rot(0.86);\n    \n    float d = toe(p);\n    p.xz *= rot(1.57);\n    p.x -= 0.43;\n    p.z = 0.25 - abs(p.z);\n    \n    return min(d, toe(p));\n}\n\nMarchData waist(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n\n    p.y += 0.65;\n    p.yz *= rot(-0.2);\n    float legAngle = legWalkAngle(1.0);\n    p.xy *= rot(legAngle * 0.3);\n    \n    vec3 pp = p;\n    pp.y += 0.3;\n    r.d = max(sdCappedCylinder(pp.zyx, 0.5, 0.5), p.y + 0.15);\n\n    // Thorax.\n    float bump = 0.5 - abs(sin(p.y * 40.0)) * 0.03;\n    float d = sdBox(p, vec3(bump, 0.15, bump));\n    \n    // Leg joins.\n    bump = 0.3 - abs(sin(p.x * 40.0)) * 0.03;\n    pp.y += 0.18;\n    d = min(d, sdCappedCylinder(pp.zyx, bump, 0.75));\n    \n    // Hips.\n    pp.x = abs(pp.x);\n    pp.yz *= rot(0.2 - 3.141 / 4.0 + legAngle * sign(p.x));\n    pp.x -= 0.98;\n    r.d = min(r.d, max(sdCappedCylinder(pp.zyx, 0.4, 0.24), -pp.y));\n    r.d = min(r.d, sdBox(pp, vec3(0.24, 0.2, 0.14 + 0.2 * pp.y)));\n    \n    // Thigh pistons.\n    vec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.12, 0.25);\n    float pistons = min(sdCappedCylinder(pp.xzy, 0.1, 0.325), sdCappedCylinder(pp.xzy, 0.05, 0.5));\n    r.d = min(r.d, max(pistons, pp.y));\n    \n    // 'Knees'.\n    p.y += 0.68;\n    r.d = min(r.d, sdBox(p, vec3(sign(abs(p.y) - 0.04) * 0.005 + 0.26, 0.2, 0.34)));\n    \n    if (d < r.d) {\n        // Black segments.\n    \tr.d = d;\n    \tr.mat = vec3(0.02);\n    }\n    \n    return r;\n}\n\nMarchData legs(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n\n    float legAngle = legWalkAngle(1.0);\n    p.z += 0.27;\n    p.yz *= rot(legAngle * sign(p.x));\n    p.z -= 0.27;\n    \n    p.y += 0.65;\n    p.yz *= rot(-0.2);\n    p.xy *= rot(legAngle * 0.3);\n    \n    vec3 pp = p;\n    pp.x = abs(pp.x);\n    pp.y += 0.48;\n    pp.yz *= rot(0.2 - 3.141 / 4.0);\n    pp.x -= 0.98;\n    \n\tvec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.12, 0.25);\n    p.y += 0.68;\n    \n    // Thighs.\n    p.xy = abs(p.xy) - 0.12;\n    float silver = sdBox(p, vec3(0.07, 0.05, 1.2));\n    \n    // Leg end cap.\n    cp -= vec3(0.0, -0.7, 0.0);\n    r.d = sdBox(cp - vec3(0.0, 0.0, 1.15), vec3(0.17, 0.17, 0.07)) - 0.04;\n    \n    // Shin.\n    cp.z += 1.0;\n    r.d = min(r.d, sdChamferedCube(cp.xzy, vec2(0.28 - sign(abs(cp.z) - 0.3) * 0.01, 0.5).xyx, 0.18));\n    \n    // Feet.\n    r.d = min(r.d, foot(cp));\n    \n    if (silver < r.d) {\n        r.d = silver;\n        r.mat = vec3(0.8);\n    }\n    \n    return r;\n}\n\nMarchData ed209(vec3 p) {\n    p.yz += vec2(legWalkAngle(2.0) * 0.2 + 0.1, -edZ());\n    \n    MarchData r = legs(p);\n    \n    float f = min(stretch * 2.0, 1.0),\n          slide = f < 0.5 ? smoothstep(0.0, 0.5, f) : (1.0 - smoothstep(0.5, 1.0, f) * 0.2);\n    p.yz -= slide * 0.5;\n    gunsUp = smoothstep(0.0, 1.0, clamp((stretch - 0.66) * 6.0, 0.0, 1.0)); // 0.66-0.83\n    gunsForward = smoothstep(0.0, 1.0, clamp((stretch - 0.83) * 6.0, 0.0, 1.0)) // 0.83-1.0\n                  + fireShock() * 0.5;\n    r = minResult(r, waist(p));\n\n    p.yz *= rot(0.1 * (-edDown + legWalkAngle(2.0) + smoothstep(0.0, 1.0, clamp((stretch - 0.5) * 6.0, 0.0, 1.0)) - 1.0)); // 0.5-0.66\n    p.xz *= rot(edTwist * 0.2);\n    r = minResult(r, headLower(p));\n    r = minResult(r, headVisor(p, 0.8, 1.0));\n\n    return minResult(r, arms(p));\n}\n\nMarchData room(vec3 p) {\n    MarchData r;\n    r.mat = vec3(0.4);\n    r.specPower = 1e7;\n\n    vec3 frameInner = vec3(2.8, 2.6, 0.1);\n\n    vec2 xy = p.xy - vec2(0.0, 2.0);\n    p.x = abs(p.x);\n    p.yz += vec2(0.5, -3.4);\n    float doorHole = sdBox(p, frameInner + vec3(0.0, 0.0, 1.0)),\n          backWall = length(p.z - 8.0);\n    r.d = min(backWall, max(length(p.z), -doorHole + 0.1));\n    \n    if (r.d == backWall) {\n        float ocp;\n        ocp = min(abs(sdOctogon(xy, 2.6)), abs(sdOctogon(xy, 1.9)));\n        ocp = max(ocp, min(0.7 - abs(xy.x + 1.2), -xy.y));\n        ocp = min(ocp, max(abs(sdOctogon(xy, 1.2)), min(xy.x, 0.7 - abs(xy.y))));\n        if (ocp < 0.3)\n        \tr.mat = vec3(0.39, 0.57, 0.71);\n    }\n    \n    float doorFrame = max(sdBox(p, frameInner + vec3(0.4, 0.4, 0.1)), -doorHole),\n          doorWidth = frameInner.x * 0.5;\n    p.x -= frameInner.x;\n    p.xz *= rot(doorOpen * 2.1);\n    p.x += doorWidth;\n    float door = sdBox(p, vec3(doorWidth, frameInner.yz));\n    \n    p = abs(p) - vec3(doorWidth * 0.5, 1.1, 0.14);\n    door = max(door, -(max(sdBox(p, vec3(0.45, 0.9, 0.1)), -sdBox(p, vec3(0.35, 0.8, 1.0)))));\n    \n    float d = min(doorFrame, door);\n    if (d < r.d) {\n        r.d = d;\n        r.mat = vec3(0.02, 0.02, 0.024);\n    \tr.specPower = 10.0;\n    }\n    \n    return r;\n}\n\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n    MarchData r = minResult(room(p), ed209(p));\n\n    float gnd = length(p.y + 3.0);\n    if (gnd < r.d) {\n        r.d = gnd;\n        r.mat = vec3(0.1);\n    }\n\n    return r;\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    // Thanks iq.\n    vec3 rd = normalize(lightPos - p);\n    \n\tfloat res = 1.0, t = 0.1;\n    for (float i = 0.0; i < SHADOW_STEPS; i++)\n    {\n\t\tfloat h = map(p + rd * t).d;\n        res = min(res, 12.0 * h / t);\n        t += h;\n        if (res < 0.001 || t > 25.0) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 p, float t) {\n    const float sceneAdjust = 0.33;\n    float d = 0.01 * t * sceneAdjust;\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * d;\n    return normalize(e.xyy * map(p + e.xyy).d + \n\t\t\t\t\t e.yyx * map(p + e.yyx).d + \n\t\t\t\t\t e.yxy * map(p + e.yxy).d + \n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n    const vec3 sunPos = vec3(10.0, 10.0, -10.0);\n    vec3 sunDir = normalize(sunPos - p), n = calcNormal(p, d);\n\n    // Primary light.\n    float primary = max(0.0, dot(sunDir, n)),\n    \n    // Secondary(/bounce) light.\n    bounce = max(0.0, dot(-sunDir, n)) * 0.2,\n\n    // Specular.\n    spe = pow(max(0.0, dot(rd, reflect(sunDir, n))), data.specPower) * 2.0,\n    \n\t// Fresnel\n    fre = smoothstep(0.7, 1.0, 1.0 + dot(rd, n)),\n    \n    // Fog\n    fog = exp(-length(p) * 0.05);\n    \n    // Combine.\n    primary *= mix(0.2, 1.0, calcShadow(p, sunPos));\n    vec3 lig = ((primary + bounce) * ao(p, n, 0.33) + spe) * vec3(2.0, 1.6, 1.7);\n    \n    return mix(data.mat * lig, vec3(0.01), fre) * fog;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n    \n    float d = 0.01;\n    MarchData h;\n    for (float steps = 0.0; steps < MAX_STEPS; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        \n        if (abs(h.d) < MIN_DIST * d)\n            break;\n        \n        if (d > MAX_DIST)\n            return vec3(0.0); // Distance limit reached - Stop.\n        \n        d += h.d; // No hit, so keep marching.\n    }\n    \n    // Lighting.\n    float g = glow;\n    return applyLighting(p, rd, d, h) + fireShock() * 0.3 + g;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    edWalk = 1.0;\n    edTwist = 0.0;\n    edDown = 0.0;\n    edShoot = 0.0;\n    doorOpen = 1.0;\n    stretch = 1.0;\n    \n    // Camera.\n    vec3 ro, lookAt;\n    float startScene, endScene, time = mod(iTime, 55.0);\n    if (time < 12.0) {\n        startScene = 0.0;\n        endScene = 12.0;\n\t    edWalk = 0.0;\n        ro = vec3(0.0, -1.5, -0.625);\n        lookAt = vec3(0.0, -1.0, edZ());\n        doorOpen = smoothstep(0.0, 1.0, time / 5.0);\n        stretch = remap(time, 7.0, 10.0, 0.0, 1.0);\n    } else if (time < 25.0) {\n        startScene = 12.0;\n        endScene = 25.0;\n        float t = time - startScene;\n        edWalk = smoothstep(0.0, 1.0, remap(t, 3.0, 8.0, 0.0, 1.0));\n        ro = vec3(-0.5 * cos(t * 0.7), 0.5 - t * 0.1, edZ() - 3.0);\n        lookAt = vec3(0.0, 0.0, edZ());\n    } else if (time < 29.0) {\n        startScene = 25.0;\n        endScene = 29.0;\n        float t = time - startScene;\n        ro = vec3(-2.0, 0.5 + t * 0.1, edZ() - 3.0);\n        lookAt = vec3(0.0, 0.0, edZ());\n    } else if (time < 37.0) {\n        startScene = 29.0;\n        endScene = 37.0;\n        float t = time - startScene;\n        ro = vec3(1.5, -1.0 - t * 0.05, edZ() - 5.0);\n        lookAt = vec3(0.0, -1.0, edZ());\n        stretch = remap(t, 2.0, 5.0, 1.0, 0.0);\n    } else if (time < 55.0) {\n        startScene = 37.0;\n        endScene = 55.0;\n        float t = time - startScene;\n        ro = vec3(-1.8, -0.5, edZ() - 2.5);\n        stretch = remap(t, 2.0, 3.0, 0.0, 1.0) - remap(t, 11.5, 14.5, 0.0, 1.0);\n        lookAt = vec3(0.0, stretch * 0.5 - 0.5, edZ());\n        edTwist = remap(t, 3.0, 3.2, 0.0, 1.0) * stretch;\n        edDown = remap(t, 3.2, 3.4, 0.0, 1.0) * stretch;\n        edShoot = t <= 9.5 ? remap(t, 4.0, 9.5, 0.0, 1.0) : 0.0;\n    }\n\n    float dim = 1.0 - cos(min(1.0, 2.0 * min(abs(time - startScene), abs(time - endScene))) * 3.141 / 2.0);\n    \n    vec3 col = vec3(0.0);\n    \n#ifdef AA\n    for (float dx = 0.0; dx <= 1.0; dx++) {\n        for (float dy = 0.0; dy <= 1.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\n#else\n            vec2 coord = fragCoord;\n#endif\n            coord += (fract(fireShock() * vec2(23242.2323, 978.23465)) - 0.5) * 10.0;\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\n            col += getSceneColor(ro, getRayDir(ro, lookAt, uv));\n#ifdef AA\n        }\n    }\n    col /= 4.0;\n#endif\n    \n    // Output to screen.\n    fragColor = vec4(vignette(pow(col * dim, vec3(0.4545)), fragCoord), 1.0);\n}\n";
        var altText = "// ED-209 (Interactive)\n// https://www.shadertoy.com/view/ddKGDW\n// Original: https://www.shadertoy.com/view/wsGczG\n//\n// Processed by 'GLSL Shader Shrinker' (10,705 to 9,801 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// I wanted to try out some mouse smoothing code, and for\n// fun decided to plug it into my ED-209 shader.\n// Look around, and aim down to shoot.\n//\n// Optimized a bit, so should be faster than the original.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n// Also to P_Malin for fixing the 'white pixel'!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat stretch, gunsUp, gunsForward, edTwist, edDown, edShoot, doorOpen, glow = 0.0;\n\nstruct MarchData {\n\tfloat d;\n\tvec3 mat; // RGB\n\tfloat specPower; // 0: None, 30.0: Shiny\n};\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) { return mix(out1, out2, clamp((f - in1) / (in2 - in1), 0., 1.)); }\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdChamferedCube(vec3 p, vec3 r, float c) {\n\tfloat cube = sdBox(p, r);\n\tp.xz *= rot(.78525);\n\tr.xz *= -c / 1.41 + 1.41;\n\treturn max(cube, sdBox(p, r));\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max(q.x * .866025 + p.y * .5, -p.y) - h.x * .5);\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tfloat rba = rb - ra,\n\t      baba = dot(b - a, b - a),\n\t      papa = dot(p - a, p - a),\n\t      paba = dot(p - a, b - a) / baba,\n\t      x = sqrt(papa - paba * paba * baba),\n\t      cax = max(0., x - ((paba < .5) ? ra : rb)),\n\t      cay = abs(paba - .5) - .5,\n\t      f = clamp((rba * (x - ra) + paba * baba) / (rba * rba + baba), 0., 1.),\n\t      cbx = x - ra - f * rba,\n\t      cby = paba - f;\n\treturn ((cbx < 0. && cay < 0.) ? -1. : 1.) * sqrt(min(cax * cax + cay * cay * baba, cbx * cbx + cby * cby * baba));\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a,\n\t     ba = b - a;\n\treturn length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0., 1.)) - r;\n}\n\nfloat sdOctogon(vec2 p, float r) {\n\tconst vec3 k = vec3(-.92387953, .38268343, .41421356);\n\tp = abs(p);\n\tp -= 2. * min(dot(k.xy, p), 0.) * k.xy;\n\tp -= 2. * min(dot(vec2(-k.x, k.y), p), 0.) * vec2(-k.x, k.y);\n\tp -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n\treturn length(p) * sign(p.y);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 forward = normalize(lookAt - ro),\n\t     right = normalize(cross(vec3(0, 1, 0), forward));\n\treturn normalize(forward + right * uv.x + cross(forward, right) * uv.y);\n}\n\nMarchData minResult(MarchData a, MarchData b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nvoid setBodyMaterial(inout MarchData mat) {\n\tmat.mat = vec3(.36, .45, .5);\n\tmat.specPower = 30.;\n}\n\nfloat fireShock() { return abs(sin(edShoot * 78.5375)); }\n\nfloat headSphere(vec3 p) { return (length(p / vec3(1, .8, 1)) - 1.) * .8; }\n\nMarchData headVisor(vec3 p, float h, float bump) {\n\tbump *= sin(p.x * 150.) * sin(p.y * 150.) * .002;\n\tMarchData result;\n\tresult.d = sdBox(p, vec3(1, h, 2));\n\tresult.d = max(mix(result.d, headSphere(p), .57), -p.y) - bump;\n\tresult.mat = vec3(.05);\n\tresult.specPower = 30.;\n\treturn result;\n}\n\nMarchData headLower(vec3 p) {\n\tvec3 op = p;\n\n\t// Start by mirroring the visor.\n\tMarchData r = headVisor(p * vec3(.95, -1.4, .95), 1., 0.);\n\n\t// Add the side panels.\n\tr.d = min(r.d, max(max(headVisor((p + vec3(0, .01, 0)) * vec3(.95), 1., 0.).d, p.y - .35), p.y * .625 - p.z - .66));\n\n\t// 'Wings'.\n\tp.xy *= rot(.075 * (gunsUp - 1.) * sign(p.x));\n\tp.x = abs(p.x) - 1.33;\n\tp.y -= .1 - p.x * .1;\n\tr.d = min(r.d, sdBox(p, vec3(.4, .06 * (1. - p.x), .3 - p.x * .2)));\n\tp = op;\n\n\t// Cut out a mouth grill.\n\tp.y = abs(abs(p.y + .147) - .0556) - .0278;\n\tr.d = max(r.d, -sdBox(p + vec3(0, 0, 1.5), vec3(mix(.25, .55, -op.y), .015, .1)));\n\n\t// 'Cheeks'.\n\tp = op;\n\tp.y = abs(p.y + .16) - .06;\n\tp.z -= -1.1;\n\tr.d = max(r.d, -max(max(sdCappedCylinder(p.xzy, 1., .03), -sdCappedCylinder(p.xzy, .55, 1.)), p.z + .2));\n\tsetBodyMaterial(r);\n\treturn r;\n}\n\nMarchData gunPod(vec3 p) {\n\tMarchData r;\n\tsetBodyMaterial(r);\n\tp.yz += vec2(.1, .45);\n\n\t// Carousel.\n\tvec3 pp = p;\n\tpp.z = abs(pp.z) - .5;\n\tr.d = sdCappedCone(pp, vec3(0), vec3(0, 0, -.1), .35 - .1, .35);\n\tr.d = min(r.d, sdCappedCylinder(p, .35, .4));\n\n\t// Triangle nobble.\n\tpp = vec3(p.x, .28 - p.y, p.z);\n\tr.d = min(r.d, sdTriPrism(pp, vec2(.1, .5)));\n\n\t// Square outriggers.\n\tpp = p;\n\tpp.x = abs(p.x);\n\tpp.xy *= rot(.78525);\n\tfloat fs,\n\t      bump = sign(sin(pp.z * 33.3)) * .003,\n\t      d = sdBox(pp, vec3(.1 - bump, .38 - bump, .34)) - .02;\n\n\t// Barrels.\n\tpp = p - vec3(0, 0, -.6);\n\tpp.x = abs(pp.x) - .1;\n\td = min(min(min(d, sdCappedCylinder(pp, .06, .15)), sdCappedCylinder(pp + vec3(0, .12, -.05), .06, .05)), sdBox(p + vec3(0, 0, .54), vec3(.1, .06, .04)));\n\tif (d < r.d) {\n\t\td = max(d, -sdCappedCylinder(pp + vec3(0, 0, .1), .03, .2));\n\t\tr.d = d;\n\t\tr.mat = vec3(.02);\n\t}\n\n\t// Muzzle flash.\n\tfs = fireShock();\n\tif (fs > .5) {\n\t\td = sdCappedCylinder(pp, .01 + pp.z * .05, fract(fs * 3322.423) * .5 + .9);\n\t\tif (d < r.d) {\n\t\t\tr.d = d;\n\t\t\tr.mat = vec3(1);\n\t\t\tglow += .1 / (.01 + d * d * 4e2);\n\t\t}\n\t}\n\n\treturn r;\n}\n\nMarchData arms(vec3 p) {\n\tconst vec3 wrist = vec3(1.5, 0, 0) - vec3(0, 0, .3);\n\tMarchData r;\n\tsetBodyMaterial(r);\n\n\t// Position origin.\n\tp.x = abs(p.x);\n\tp.yz += vec2(.24, 0);\n\tp.xy *= rot(.15 * (gunsUp - 1.));\n\n\t// Shoulder and forearm.\n\tr.d = min(sdCapsule(p, vec3(0), vec3(1.5, 0, 0), .2), sdCapsule(p, vec3(1.5, 0, 0), wrist, .2));\n\n\t// Gunz.\n\tp -= wrist;\n\tp.z -= gunsForward * .15;\n\treturn minResult(r, gunPod(p));\n}\n\nfloat toe(vec3 p) {\n\tp.yz += vec2(.1, .32);\n\treturn max(sdBox(p, vec3(.3 + .2 * (p.z - .18) - p.y * .228, .3 + .2 * cos((p.z - .18) * 3.69), .35)), .1 - p.y);\n}\n\nfloat foot(vec3 p) {\n\tp.z += .8;\n\tp.yz *= rot(.86);\n\tfloat d = toe(p);\n\tp.xz *= rot(1.57);\n\tp.x -= .43;\n\tp.z = .25 - abs(p.z);\n\treturn min(d, toe(p));\n}\n\nMarchData waist(vec3 p) {\n\tMarchData r;\n\tsetBodyMaterial(r);\n\tp.y += .65;\n\tp.yz *= rot(-.2);\n\tfloat bump, d,\n\t      legAngle = 0.0;\n\tp.xy *= rot(legAngle * .3);\n\tvec3 pp = p;\n\tpp.y += .3;\n\tr.d = max(sdCappedCylinder(pp.zyx, .5, .5), p.y + .15);\n    \n    if (abs(p.x) > 1.5) return r;\n\n\t// Thorax.\n\tbump = .5 - abs(sin(p.y * 40.)) * .03;\n\td = sdBox(p, vec3(bump, .15, bump));\n\n\t// Leg joins.\n\tbump = .3 - abs(sin(p.x * 40.)) * .03;\n\tpp.y += .18;\n\td = min(d, sdCappedCylinder(pp.zyx, bump, .75));\n\n\t// Hips.\n\tpp.x = abs(pp.x);\n\tpp.yz *= rot(-.58525 + legAngle * sign(p.x));\n\tpp.x -= .98;\n\tr.d = min(r.d, max(sdCappedCylinder(pp.zyx, .4, .24), -pp.y));\n\tr.d = min(r.d, sdBox(pp, vec3(.24, .2, .14 + .2 * pp.y)));\n\n\t// Thigh pistons.\n\tp = pp;\n\tpp.xz = abs(pp.xz) - vec2(.12, .25);\n\tr.d = min(r.d, max(min(sdCappedCylinder(pp.xzy, .1, .325), sdCappedCylinder(pp.xzy, .05, .5)), pp.y));\n\n\t// 'Knees'.\n\tp.y += .68;\n\tr.d = min(r.d, sdBox(p, vec3(sign(abs(p.y) - .04) * .005 + .26, .2, .34)));\n\tif (d < r.d) {\n\t\t// Black segments.\n\t\tr.d = d;\n\t\tr.mat = vec3(.02);\n\t}\n\n\treturn r;\n}\n\nMarchData legs(vec3 p) {\n\tMarchData r;\n\tsetBodyMaterial(r);\n\tfloat silver,\n\t      legAngle = 0.0;\n\tp.z += .27;\n\tp.yz *= rot(legAngle * sign(p.x));\n\tp.z -= .27;\n\tp.y += .65;\n\tp.yz *= rot(-.2);\n\tp.xy *= rot(legAngle * .3);\n\tvec3 cp,\n\t     pp = p;\n\tpp.x = abs(pp.x);\n\tpp.y += .48;\n\tpp.yz *= rot(-.58525);\n\tpp.x -= .98;\n\tcp = pp;\n\tp = pp;\n\tpp.xz = abs(pp.xz) - vec2(.12, .25);\n\tp.y += .68;\n\n\t// Thighs.\n\tp.xy = abs(p.xy) - .12;\n\tsilver = sdBox(p, vec3(.07, .05, 1.2));\n\n\t// Leg end cap.\n\tcp -= vec3(0, -.7, 0);\n\tr.d = sdBox(cp - vec3(0, 0, 1.15), vec3(.17, .17, .07)) - .04;\n    \n    if (abs(p.x) > 1.2) return r;\n\n\t// Shin.\n\tcp.z++;\n\tr.d = min(r.d, sdChamferedCube(cp.xzy, vec2(.28 - sign(abs(cp.z) - .3) * .01, .5).xyx, .18));\n\n\t// Feet.\n\tr.d = min(r.d, foot(cp));\n\tif (silver < r.d) {\n\t\tr.d = silver;\n\t\tr.mat = vec3(.8);\n\t}\n\n\treturn r;\n}\n\nMarchData ed209(vec3 p) {\n\tp.yz += vec2(.1, -5);\n\tMarchData r = legs(p);\n    if (r.d > 3.2) return r;\n    \n\tfloat f = min(stretch * 2., 1.),\n\t      slide = f < .5 ? smoothstep(0., .5, f) : (1. - smoothstep(.5, 1., f) * .2);\n\tp.yz -= slide * .5;\n\tgunsUp = smoothstep(0., 1., clamp((stretch - .66) * 6., 0., 1.)); // 0.66-0.83\n\tgunsForward = smoothstep(0., 1., clamp((stretch - .83) * 6., 0., 1.)) // 0.83-1.0\n\t + fireShock() * .5;\n\tr = minResult(r, waist(p));\n\tp.yz *= rot(.1 * (-edDown + smoothstep(0., 1., clamp((stretch - .5) * 6., 0., 1.)) - 1.)); // 0.5-0.66\n\tp.xz *= rot(edTwist * .2);\n\treturn minResult(minResult(minResult(r, headLower(p)), headVisor(p, .8, 1.)), arms(p));\n}\n\nMarchData room(vec3 p) {\n\tconst vec3 frameInner = vec3(2.8, 2.6, .1);\n\tMarchData r;\n\tr.mat = vec3(.4);\n\tr.specPower = 1e7;\n\tvec2 xy = p.xy - vec2(0, 2);\n\tp.x = abs(p.x);\n\tp.yz += vec2(.5, -3.4);\n\tfloat doorFrame, doorWidth, door, d,\n\t      doorHole = sdBox(p, frameInner + vec3(0, 0, 1)),\n\t      backWall = 8. - p.z;\n\tr.d = min(backWall, max(length(p.z), -doorHole + .1));\n\tif (abs(r.d - backWall) < 0.01) {\n\t\tfloat ocp = min(abs(sdOctogon(xy, 2.6)), abs(sdOctogon(xy, 1.9)));\n\t\tocp = min(max(ocp, min(.7 - abs(xy.x + 1.2), -xy.y)), max(abs(sdOctogon(xy, 1.2)), min(xy.x, .7 - abs(xy.y))));\n\t\tif (ocp < .3) r.mat = vec3(.39, .57, .71);\n\t}\n\n\tdoorFrame = max(sdBox(p, frameInner + vec3(.4, .4, .1)), -doorHole);\n\tdoorWidth = frameInner.x * .5;\n\tp.x -= frameInner.x;\n\tp.xz *= rot(doorOpen * 2.1);\n\tp.x += doorWidth;\n\tdoor = sdBox(p, vec3(doorWidth, frameInner.yz));\n\tp = abs(p) - vec3(doorWidth * .5, 1.1, .14);\n\td = min(doorFrame, max(door, -max(sdBox(p, vec3(.45, .9, .1)), -sdBox(p, vec3(.35, .8, 1)))));\n\tif (d < r.d) {\n\t\tr.d = d;\n\t\tr.mat = vec3(.02, .02, .024);\n\t\tr.specPower = 10.;\n\t}\n\n\treturn r;\n}\n\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n\tMarchData r = minResult(room(p), ed209(p));\n\tfloat gnd = length(p.y + 3.);\n\tif (gnd < r.d) {\n\t\tr.d = gnd;\n\t\tr.mat = vec3(.1);\n\t}\n\n\treturn r;\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n\t// Thanks iq.\n\tvec3 rd = normalize(lightPos - p);\n\tfloat res = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = map(p + rd * t).d;\n\t\tres = min(res, 12. * h / t);\n\t\tt += h;\n\t\tif (res < .001 || t > 25.) break;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nvec3 calcNormal(vec3 p, float t) {\n\tfloat d = .01 * t * .33;\n\tvec2 e = vec2(1, -1) * .5773 * d;\n\treturn normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return clamp(map(p + h * n).d / h, 0.0, 1.0); }\n\n/**********************************************************************************/\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n\tvec3 sunP = vec3(10, 10, -10),\n         sunDir = normalize(sunP - p),\n\t     n = calcNormal(p, d);\n\n\t// Primary light.\n\tfloat primary = max(0., dot(sunDir, n)),\n\t      bounce = max(0., dot(-sunDir, n)) * .3,\n\t      spe = pow(max(0., dot(rd, reflect(sunDir, n))), data.specPower) * 2.,\n\t      fre = smoothstep(.7, 1., 1. + dot(rd, n)),\n\t      fog = exp(-length(p) * .05);\n    primary /= pow(length(sunP - p) / 15., 3.0);\n    if (data.specPower > 1e6) spe *= 0.;\n\n\t// Combine.\n\tprimary *= mix(.2, 1., calcShadow(p, vec3(10, 10, -10)));\n\treturn mix(data.mat * ((primary + bounce) * ao(p, n, .33) + spe) * vec3(2, 1.6, 1.7), vec3(.01), fre) * fog;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\tfloat g,\n\t      d = .01;\n\tMarchData h;\n\tfor (float steps = 0.; steps < 120.; steps++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015 * d) break;\n\t\tif (d > 64.) return vec3(0); // Distance limit reached - Stop.\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\t// Lighting.\n\tg = glow;\n\treturn applyLighting(p, rd, d, h) + fireShock() * .02 + g;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tedTwist = 0.;\n\tedDown = 0.;\n\tedShoot = 0.;\n    doorOpen = smoothstep(0., 1., iTime / 5.);\n\tstretch = 1.;\n\n\t// Camera.\n\tvec3 ro, lookAt, col;\n\t\tro = vec3(sin(iTime * 0.5) * 0.2, -1.5, -.625);\n\t\tlookAt = vec3(0, -1, 5);\n\n    vec2 m = vec2(texelFetch(iChannel0, ivec2(1), 0).a, texelFetch(iChannel0, ivec2(3), 0).a);\n    edTwist = m.x * 3. - 1.5;\n    edDown = (1. - m.y) * 3. + sin(iTime) * 0.5;\n    stretch = m.y;\n    edShoot = (iTime * 0.3) * step(m.y, 0.3) * step(3., iTime);\n\n    vec2 coord = fragCoord;\n    coord += (fract(fireShock() * vec2(23242.232, 978.23465)) - .5) * 10.;\n    vec2 uv = (coord - .5 * iResolution.xy) / iResolution.y;\n    col = getSceneColor(ro, getRayDir(ro, lookAt, uv));\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * clamp(iTime, 0.0, 1.0), vec3(.4545)), fragCoord), 1);\n}";

        var differ = new Differ();
        var diffBuilder = new InlineDiffBuilder(differ);
        var diff = diffBuilder.BuildDiffModel(oldText, altText, true);

        foreach (var line in diff.Lines)
        {
            switch (line.Type)
            {
                case ChangeType.Inserted:
                    Diffs.Add(new CombinedDiff(null, line));
                    break;
                case ChangeType.Deleted:
                    Diffs.Add(new CombinedDiff(line, null));
                    break;
                case ChangeType.Unchanged:
                    Diffs.Add(new CombinedDiff(line, line));
                    break;
            }
        }
    }
}